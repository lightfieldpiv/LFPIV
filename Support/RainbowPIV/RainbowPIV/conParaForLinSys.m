function [A,b] = conParaForLinSys( F, Ix, Iy, Iz, It, UV, u, z, dx, dy, dz, Rp,...
    Rpt, L, lambda, kappa, rho, npixels, iteOut, iteFrame, iteAdmm, numFrame, ratio )
    
    %% for Z axs
    lambdaZ = ratio*ratio*lambda;
    %%
    tmp_UV = UV;
    tmp_UV(:,:,:,3,:) = tmp_UV(:,:,:,3,:)./ratio;
    
    U = reshape(tmp_UV(:,:,:,1,iteFrame),npixels,1);
    V = reshape(tmp_UV(:,:,:,2,iteFrame),npixels,1);
    W = reshape(tmp_UV(:,:,:,3,iteFrame),npixels,1);
    
    tmp_z = z;
    tmp_z(:,3) = tmp_z(:,3)./ratio;
    tmp_u = u;
    tmp_u(:,3) = tmp_u(:,3)./ratio;
    
    [H, w, D] = size( UV(:,:,:,1) );
    [x1, y1, z1] = meshgrid(1:w,1:H,1:D);
    
    % mask for data consistency
    maskIx = F.*Ix;
    maskIy = F.*Iy;
    maskIz = F.*Iz;
        
    % mask for temporal coherence
    mask = zeros( H, w, D );
    mask( 5:end-5, 5:end-5, 3:end-3 ) = 1;
    mask = spdiags( reshape(mask,npixels,1), 0, npixels, npixels );

    if numFrame-1==1
        if iteAdmm == 1
            A = [ maskIx*Ix+lambda*L maskIx*Iy maskIx*Iz; ...
                  Ix*maskIy maskIy*Iy+lambda*L maskIy*Iz; ...
                  Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L ];
            b = -[ maskIx*It + lambda*L*U ; ...
                   maskIy*It + lambda*L*V ; ...
                   maskIz*It + lambdaZ*L*W ];
        else
            A = [ maskIx*Ix+lambda*L+rho.*speye(npixels) maskIx*Iy maskIx*Iz; ...
                  Ix*maskIy maskIy*Iy+lambda*L+rho.*speye(npixels) maskIy*Iz; ...
                  Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+rho.*speye(npixels)];
            b = -[ maskIx*It + lambda*L*U + rho.*(U-z(:,1)+u(:,1)) ; ...
                   maskIy*It + lambda*L*V + rho.*(V-z(:,2)+u(:,2)); ...
                   maskIz*It + lambdaZ*L*W + rho.*(W-tmp_z(:,3)+tmp_u(:,3))];
        end
    elseif iteFrame==1
        if iteOut==1
            if iteAdmm == 1
                A = [ maskIx*Ix+lambda*L maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L ];
                b = -[ maskIx*It + lambda*L*U ; ...
                       maskIy*It + lambda*L*V ; ...
                       maskIz*It + lambdaZ*L*W ];
            else
                A = [ maskIx*Ix+lambda*L+rho.*speye(npixels) maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+rho.*speye(npixels) maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+rho.*speye(npixels)];
                b = -[ maskIx*It + lambda*L*U + rho.*(U-z(:,1)+u(:,1)) ; ...
                       maskIy*It + lambda*L*V + rho.*(V-z(:,2)+u(:,2)); ...
                       maskIz*It + lambdaZ*L*W + rho.*(W-tmp_z(:,3)+tmp_u(:,3))];
            end
        else
            x2 = x1 + tmp_UV(:,:,:,1,iteFrame);
            y2 = y1 + tmp_UV(:,:,:,2,iteFrame);
            z2 = z1 + tmp_UV(:,:,:,3,iteFrame);
            warpBackUV = cat(4, interp_valid(UV(:,:,:,1,iteFrame+1),x2,y2,z2,'cubic'),...
            interp_valid(UV(:,:,:,2,iteFrame+1),x2,y2,z2,'cubic'), ...
            interp_valid(UV(:,:,:,3,iteFrame+1),x2,y2,z2,'cubic') );
            warpBackUV = reshape( warpBackUV, npixels, 3 );
            warpBackUV = flowProjection( warpBackUV, dx, dy, dz, Rp, Rpt );
            warpBackUV(:,3) = warpBackUV(:,3)./ratio;
            
            if iteAdmm == 1
                A = [ maskIx*Ix+lambda*L+kappa.*mask maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+kappa.*mask maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+kappa.*mask ];
                b = -[ maskIx*It + lambda*L*U + kappa*mask*(U-warpBackUV(:,1)) ; ...
                       maskIy*It + lambda*L*V + kappa*mask*(V-warpBackUV(:,2)) ; ...
                       maskIz*It + lambdaZ*L*W + kappa*mask*(W-warpBackUV(:,3)) ];
            else
                A = [ maskIx*Ix+lambda*L+kappa*mask+rho.*speye(npixels) maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+kappa*mask+rho.*speye(npixels) maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+kappa*mask+rho.*speye(npixels)];
                b = -[ maskIx*It + lambda*L*U + kappa*mask*(U-warpBackUV(:,1)) + rho.*(U-z(:,1)+u(:,1)) ; ...
                       maskIy*It + lambda*L*V + kappa*mask*(V-warpBackUV(:,2)) + rho.*(V-z(:,2)+u(:,2)); ...
                       maskIz*It + lambdaZ*L*W + kappa*mask*(W-warpBackUV(:,3)) + rho.*(W-tmp_z(:,3)+tmp_u(:,3))];
            end
        end
    elseif iteFrame<numFrame-1
        x2 = x1 + tmp_UV(:,:,:,1,iteFrame);
        y2 = y1 + tmp_UV(:,:,:,2,iteFrame);
        z2 = z1 + tmp_UV(:,:,:,3,iteFrame);
        warpBackUV = cat(4, interp_valid(UV(:,:,:,1,iteFrame+1),x2,y2,z2,'cubic'),...
        interp_valid(UV(:,:,:,2,iteFrame+1),x2,y2,z2,'cubic'), ...
        interp_valid(UV(:,:,:,3,iteFrame+1),x2,y2,z2,'cubic'));
        warpBackUV = reshape( warpBackUV, npixels, 3 );
        warpBackUV = flowProjection( warpBackUV, dx, dy, dz, Rp, Rpt );
        warpBackUV(:,3) = warpBackUV(:,3)./ratio;
        
        x3 = x1 - tmp_UV(:,:,:,1,iteFrame-1);
        y3 = y1 - tmp_UV(:,:,:,2,iteFrame-1);
        z3 = z1 - tmp_UV(:,:,:,3,iteFrame-1);
        warpForwUV = cat(4, interp_valid(UV(:,:,:,1,iteFrame-1),x3,y3,z3,'cubic'),...
        interp_valid(UV(:,:,:,2,iteFrame-1),x3,y3,z3,'cubic'), ...
        interp_valid(UV(:,:,:,3,iteFrame-1),x3,y3,z3,'cubic'));
        warpForwUV = reshape( warpForwUV, npixels, 3 );
        warpForwUV = flowProjection( warpForwUV, dx, dy, dz, Rp, Rpt );
        warpForwUV(:,3) = warpForwUV(:,3)./ratio;
        
        if iteOut==1
            if iteAdmm == 1
                A = [ maskIx*Ix+lambda*L+kappa.*mask maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+kappa.*mask maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+kappa.*mask ];
                b = -[ maskIx*It + lambda*L*U + kappa*mask*(U-warpForwUV(:,1)); ...
                       maskIy*It + lambda*L*V + kappa*mask*(V-warpForwUV(:,2)); ...
                       maskIz*It + lambdaZ*L*W + kappa*mask*(W-warpForwUV(:,3))];
            else
                A = [ maskIx*Ix+lambda*L+kappa*mask+rho.*speye(npixels) maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+kappa*mask+rho.*speye(npixels) maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+kappa*mask+rho.*speye(npixels)];
                b = -[ maskIx*It + lambda*L*U + kappa*mask*(U-warpForwUV(:,1)) + rho.*(U-z(:,1)+u(:,1)) ; ...
                       maskIy*It + lambda*L*V + kappa*mask*(V-warpForwUV(:,2)) + rho.*(V-z(:,2)+u(:,2)); ...
                       maskIz*It + lambdaZ*L*W + kappa*mask*(W-warpForwUV(:,3)) + rho.*(W-tmp_z(:,3)+tmp_u(:,3))];
            end
        else
            if iteAdmm == 1
                A = [ maskIx*Ix+lambda*L+2*kappa.*mask maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+2*kappa.*mask maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+2*kappa.*mask ];
                b = -[ maskIx*It + lambda*L*U + kappa*mask*(2*U-warpForwUV(:,1)-warpBackUV(:,1)); ...
                       maskIy*It + lambda*L*V + kappa*mask*(2*V-warpForwUV(:,2)-warpBackUV(:,2)); ...
                       maskIz*It + lambdaZ*L*W + kappa*mask*(2*W-warpForwUV(:,3)-warpBackUV(:,3))];
            else            
                A = [ maskIx*Ix+lambda*L+2*kappa*mask+rho.*speye(npixels) maskIx*Iy maskIx*Iz; ...
                      Ix*maskIy maskIy*Iy+lambda*L+2*kappa*mask+rho.*speye(npixels) maskIy*Iz; ...
                      Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+2*kappa*mask+rho.*speye(npixels)];
                b = -[ maskIx*It + lambda*L*U + kappa*mask*(2*U-warpForwUV(:,1)-warpBackUV(:,1)) + rho.*(U-z(:,1)+u(:,1)) ; ...
                       maskIy*It + lambda*L*V + kappa*mask*(2*V-warpForwUV(:,2)-warpBackUV(:,2)) + rho.*(V-z(:,2)+u(:,2)); ...
                       maskIz*It + lambdaZ*L*W + kappa*mask*(2*W-warpForwUV(:,3)-warpBackUV(:,3)) + rho.*(W-tmp_z(:,3)+tmp_u(:,3))];
            end
        end
    else
        x3 = x1 - tmp_UV(:,:,:,1,iteFrame-1);
        y3 = y1 - tmp_UV(:,:,:,2,iteFrame-1);
        z3 = z1 - tmp_UV(:,:,:,3,iteFrame-1);
        warpForwUV = cat(4, interp_valid(UV(:,:,:,1,iteFrame-1),x3,y3,z3,'cubic'),...
        interp_valid(UV(:,:,:,2,iteFrame-1),x3,y3,z3,'cubic'), ...
        interp_valid(UV(:,:,:,3,iteFrame-1),x3,y3,z3,'cubic') );
        warpForwUV = reshape( warpForwUV, npixels, 3 );
        warpForwUV = flowProjection( warpForwUV, dx, dy, dz, Rp, Rpt );
        warpForwUV(:,3) = warpForwUV(:,3)./ratio;
        
        if iteAdmm == 1
            A = [ maskIx*Ix+lambda*L+kappa.*mask maskIx*Iy maskIx*Iz; ...
                  Ix*maskIy maskIy*Iy+lambda*L+kappa.*mask maskIy*Iz; ...
                  Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+kappa.*mask ];
            b = -[ maskIx*It + lambda*L*U + kappa*mask*(U-warpForwUV(:,1)); ...
                   maskIy*It + lambda*L*V + kappa*mask*(V-warpForwUV(:,2)); ...
                   maskIz*It + lambdaZ*L*W + kappa*mask*(W-warpForwUV(:,3))];
        else                
            A = [ maskIx*Ix+lambda*L+kappa*mask+rho.*speye(npixels) maskIx*Iy maskIx*Iz; ...
                  Ix*maskIy maskIy*Iy+lambda*L+kappa*mask+rho.*speye(npixels) maskIy*Iz; ...
                  Ix*maskIz  Iy*maskIz  Iz*maskIz+lambdaZ*L+kappa*mask+rho.*speye(npixels)];
            b = -[ maskIx*It + lambda*L*U + kappa*mask*(U-warpForwUV(:,1)) + rho.*(U-z(:,1)+u(:,1)) ; ...
                   maskIy*It + lambda*L*V + kappa*mask*(V-warpForwUV(:,2)) + rho.*(V-z(:,2)+u(:,2)); ...
                   maskIz*It + lambdaZ*L*W + kappa*mask*(W-warpForwUV(:,3)) + rho.*(W-tmp_z(:,3)+tmp_u(:,3))];
        end
    end
end